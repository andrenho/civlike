module;

#include "SDL2/SDL.h"
#include "SDL2/SDL_ttf.h"

#include <algorithm>
#include <optional>

#include "font.h"

export module uiproto;

import civlike;

export class UIProto {
public:
    explicit UIProto(Nation::Id player_nation_id)
    {
        SDL_Init(SDL_INIT_VIDEO | SDL_INIT_EVENTS | SDL_INIT_TIMER);
        SDL_SetHint(SDL_HINT_RENDER_VSYNC, "1");
        TTF_Init();
        window = SDL_CreateWindow("civlike (uiproto)", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
            800, 600, SDL_WINDOW_RESIZABLE);
        ren = SDL_CreateRenderer(window, -1, 0);

        SDL_RWops* font_mem = SDL_RWFromMem(font, font_len);
        font = TTF_OpenFontRW(font_mem, 1, 16);
    }

    ~UIProto()
    {
        TTF_CloseFont(font);
        SDL_DestroyRenderer(ren);
        SDL_DestroyWindow(window);
        TTF_Quit();
        SDL_Quit();
    }

    void run(Game& game)
    {
        while (true) {
            do_events(game);
            draw(game);
        }
    }

private:
    void do_events(Game& game)
    {
        SDL_Event e;
        while (SDL_PollEvent(&e)) {
            switch (e.type) {
                case SDL_QUIT:
                    SDL_Quit();
                    exit(0);
                    break;
                case SDL_KEYDOWN:
                    switch (e.key.keysym.sym) {
                        case SDLK_q:
                            SDL_Quit();
                            exit(0);
                            break;
                    }
            }
        }
    }

    void draw(Game const& game) const
    {
        SDL_SetRenderDrawColor(ren, 255, 255, 255, SDL_ALPHA_OPAQUE);
        SDL_RenderClear(ren);

        for (size_t x = 0; x < game.map_size.w; ++x)
            for (size_t y = 0; y < game.map_size.h; ++y)
                draw_tile(game, x, y);

        SDL_RenderPresent(ren);
    }

    void draw_tile(Game const& game, size_t x, size_t y) const
    {
        auto t_clr = game.ruleset.terrains.at(game.tiles.at(x).at(y).terrain_id).color;
        SDL_SetRenderDrawColor(ren, t_clr.r, t_clr.g, t_clr.b, SDL_ALPHA_OPAQUE);
        SDL_Rect r { .x = (int) (x * TILE_SIZE), .y = (int) (y * TILE_SIZE), .w = TILE_SIZE, .h = TILE_SIZE };
        SDL_RenderFillRect(ren, &r);
        SDL_SetRenderDrawColor(ren, 0, 0, 0, SDL_ALPHA_OPAQUE);
        SDL_RenderDrawPoint(ren, r.x, r.y);

        std::optional<Unit const*> o_unit = unit_to_draw(game, x, y);
        if (o_unit.has_value())
            draw_unit(game, **o_unit);
    }

    // TODO - actual implementation
    std::optional<Unit const*> unit_to_draw(Game const& game, size_t x, size_t y) const
    {
        auto units = game.units_in_xy(x, y);
        // TODO - std::find_if(units.begin(), units.end(), [](Unit const* unit) { return unit->focused; });
        return units.empty() ? std::optional<Unit const*>{} : units[0];
    }

    void draw_unit(Game const& game, Unit const& unit) const
    {
        auto color = game.ruleset.nations.at(unit.nation_id).color;
        SDL_SetRenderDrawColor(ren, color.r, color.g, color.b, SDL_ALPHA_OPAQUE);
        SDL_Rect r { .x = (int) (unit.pos.x * TILE_SIZE), .y = (int) (unit.pos.y * TILE_SIZE), .w = TILE_SIZE, .h = TILE_SIZE };
        SDL_RenderDrawRect(ren, &r);
        ++r.x, ++r.y, r.w -= 2, r.h -= 2;
        SDL_RenderDrawRect(ren, &r);
    }

    SDL_Window* window = nullptr;
    SDL_Renderer* ren = nullptr;
    TTF_Font* font = nullptr;
    static constexpr size_t TILE_SIZE = 32;
};